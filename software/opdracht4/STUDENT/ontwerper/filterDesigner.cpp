/////////////////////////////////////////////////////////////////////////////
// Name:        filterDesigner.cpp
// Purpose:     
// Author:      Ewout Boks
// Modified by: 
// Created:     Thursday, 24 June 2021 at 15:51:14
// RCS-ID:      
// Copyright:   (c)2012-2021 ir drs E.J Boks, Hogeschool van Arnhem en Nijmegen
// Licence:
/////////////////////////////////////////////////////////////////////////////

// -*- C++ -*- generated by wxGlade 0.6.3 on Tue Feb 28 14:23:33 2012
/*!
@file
Opdracht 4 DSB practicum (ontwerper gedeelte).
 Werk deze opdracht verder uit aan de hand van het kommentaar.
Assignment 4 DSB practical (designer part). Elaborate this assignment on the basis of the comments.
@version $Rev: 313 $
@author $Author: ewout $

@copyright Copyright 2006-2022 ir drs E.J Boks, Hogeschool van Arnhem en Nijmegen. https://ese.han.nl/~ewout

$URL: https://ese.han.nl/svn/dsbpracticum/trunk/2022/software/opdracht4/STUDENT/ontwerper/filterDesigner.cpp $
$Id: filterDesigner.cpp 313 2023-01-30 13:54:35Z ewout $
************************************************************************/

#ifndef OnderwijsOntwikkeling
#if defined(InterfaceTaalNederlands)
/* Verwijder dit directief na het invullen van de naam en het studentnummer hieronder. */
#error  "Student naam en nummer moeten beneden in de velden worden ingevuld."
#elif defined (InterfaceTaalEnglish)
/* Remove this directive after filling out name and student number below. */
#error  "Student name and number must be entered into the fields below."
#endif
#endif

/********  Naam/name     :               ******/
/********  Studentnummer :               ******/

// For compilers that support precompilation, includes "wx/wx.h".

#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
#include "wx/mstream.h"
////@end includes

#include "filterDesigner.h"

////@begin XPM images
#include "../../../DesktopBasis/gemeenschappelijk/logos/hanlogo_klein.inc"
////@end XPM images

#include <applikatie4.h>
#include <wx/wfstream.h>
#include <wx/txtstrm.h>
#include <wx/numdlg.h>
#include <wx/filename.h>

#ifdef InterfaceTaalNederlands
double FilterVenster::driehoek(const Int32 n ) const
{
	/*! @note schrijf in deze funktie de code om de driehoek funktie te implementeren.
	 * @warning Let op de formule in Lynn & Fürst is niet goed. */
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}


double FilterVenster::hamming(const Int32 n ) const
{
	/*! @note schrijf in deze funktie de code om de Hamming funktie te implementeren. */
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}


double FilterVenster::sinc(const double hoek )
{
	/*! @note schrijf in deze funktie de code om de sinc() funktie te implementeren. */
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}

void FilterVenster::berekenFilter(wxCommandEvent &event)
{
	/*! @note Nederlands : schrijf in deze funktie de code om de tijddomeincoefficienten
	 * van het filter te bereken.
     * Maak hier voor gebruik van de Fourier ontwerp methode (Lynn & Fürst §5.3)
     * voor een bandfilter:
     * h[n] = (Omega1/pi)*sinc(Omega1*n) : Dit is een laagdoorlaatfilter
     * vermenigvuldig dit in tijddomein met cos(Omega0*n) -->
     * in frequentiedomein convolueer met delta(Omega0) -->
     * verschuiving van begin LDF van 0 naar Omega0 */
	
	/* filter maakt gebruik van Hamming Venster :
	 * Zie boek Andriessen / Lynn & Fürst, blz 156
	 * of Lynn & Fürst, blz 150.
	 */
	
	/* een array van wxPoints die je kunt gebruiken om de impulsresponsie te tekenen. */
	PuntLijst impulsResponsie;
	
	/* Verwijder oude filter coefficienten voor de berekening begint. */
	filterCoeffs.Clear();
	
	wxLogDebug(_("filter berekening start."));
	wxBusyCursor bezig;

#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	/* schakel ook de test knop nu in */
	berekeningKlaar = true;
}


void FilterVenster::berekenFreqResponsie()
{
	/*! @note schrijf in deze funktie de code om het  frequentiebeeld te bereken op
	 * basis van de tijddomeincoefficienten. */
	
	H_Omega.Clear();
	
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}

void FilterVenster::tekenFreqSpectrum() const
{
	/*! @note schrijf in deze funktie de code om het berekende frequentiebeeld in het
	 * venster freqDomeinGrafiek te tekenen. */
	const wxSize veld(freqDomeinGrafiek->geefTekenVeldGrootte());
	const unsigned int aantalPunten = FreqSpectrumPunten(taps);
	const auto stapGrootte = (Pi/aantalPunten);
	
	/* teken de lijnen van het freqdomein filter */
	
	/* toon het berekende venster in het frequentiedomein */
	freqDomeinGrafiek->maakSchoon();
	
	freqDomeinGrafiek->tekenAssenstelsel();
	
	const wxCoord veldEinde(-3*veld.GetHeight()/4);
	
	const double schaalx = (1.0*veld.GetWidth())/(Pi);
	const double schaaly = (3*veld.GetHeight()/(4*fabs(H_Omega_max-H_Omega_min)));
	
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("BLUE")), 2, wxPENSTYLE_SOLID));
	
	/* Teken de spectrale componenten */
	double omega=0;
	for(Teller index=0;index<aantalPunten;index++)
	{
		const auto xcoord = (wxCoord)(omega*schaalx);
		const wxPoint begin(xcoord,veldEinde);
		const wxPoint einde(xcoord,(wxCoord)(schaaly*H_Omega[index]));
		const LijnStuk lijn(begin, einde);
//		wxLogDebug(wxT("H(%.2lf) = %lf"),omega,schaaly*(*(H_Omega+index)));
		freqDomeinGrafiek->tekenLijn(lijn);
		omega+=stapGrootte;
	}
	
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREEN")), 3, wxPENSTYLE_SOLID));
	
	/* teken verticale lijnen op pi/6 */
	UInt32 omnummer=0;
	for(omega=0;omega<Pi;omega+=(Pi/6),omnummer++)
	{
		const auto xcoord = (wxCoord)(omega*schaalx);
		freqDomeinGrafiek->tekenVerticaleLijn(xcoord);
		const wxPoint tekstpunt(xcoord, freqDomeinGrafiek->geefMaxY());
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%dpi/6"),omnummer), tekstpunt);
	}
	
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREY")), 3, wxPENSTYLE_SOLID));
	/* teken horizontale lijnen op -10 db afstand */
	for (auto dblijn=0;dblijn>H_Omega_min;dblijn-=10)
	{
		const auto ycoord = static_cast<wxCoord>(dblijn*schaaly);
		freqDomeinGrafiek->tekenHorizontaleLijn(ycoord);
		const wxPoint tekstpunt(freqDomeinGrafiek->geefMaxX()-30,ycoord);
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%d dB"),
		                                                   static_cast<Int32>(dblijn)), tekstpunt);
	}
	/* teken beginband en stopband */
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("PINK")), 3, wxPENSTYLE_SHORT_DASH));
	
	/* begin vd band */
	omega = 2*Pi*filterBegin/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));
	/* eind vd band */
	omega = 2*Pi*filterEind/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));
	
	const auto freqGrootte(freqDomeinGrafiek->GetClientSize());
	freqDomeinGrafiek->zetNormaleTekst(DemoTekst,wxPoint(freqGrootte.GetWidth()/16, -20));
	
	
}

Int16 FilterVenster::berekenFixedPoint(const float flp) const
{
	/*! @note Bereken in deze funktie de conversie van floating point naar fixed point
	 * op basis van de instelling in fipBitsSpinCtrl. */
	
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}

float FilterVenster::berekenFloatingPoint(const Int16 fixp) const
{
	/*! @note Bereken in deze funktie de conversie van fixed point naar floating point
	 * op basis van de instelling in fipBitsSpinCtrl. */
	
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}


#elif defined(InterfaceTaalEnglish)

double FilterVenster::triangle(const Int32 n ) const
{
	/*! @note Write in this function the code to implement the triangle function.
	 * Note the formula in Lynn & Fürst is not good.*/
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}


double FilterVenster::hamming(const Int32 n ) const
{
	/*! @note Write in this function the code to implement the Hamming function.*/
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}


double FilterVenster::sinc(const double angle ) const
{
	/*! @note Write the code in this function to implement the sinc () function. */
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}

void FilterVenster::computeFilter(wxCommandEvent &event)
{
	/*! @note Write the code to the time domain coefficients in this function
	  * of the filter.
      * Make use of the Fourier design method here (Lynn & Fürst §5.3)
      * for a band filter:
      * h [n] = (Omega1 / pi) * sinc (Omega1 * n): This is a low-pass filter
      * multiply this in time domain by cos (Omega0 * n) ->
      * Convolve in frequency domain with delta (Omega0) ->
      * shift from start LDF from 0 to Omega0  */

	/* filter uses Hamming Window :
	 * See book Lynn & Fürst, page 150. */

	/* an array of wxPoints that you can use to draw the impulse response */
	PointList impulseResponse;

	/* Verwijder oude filter coefficienten voor de berekening begint.
	 * Remove old filter coefficients before the calculation starts.*/
	filterCoeffs.Clear();

	wxLogDebug(_("filter calculation start."));
	wxBusyCursor busy;

#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	/* switch on the test button*/
	berekeningKlaar = true;
}


void FilterVenster::computeFreqResponse()
{
	/*! @note write the code to calculate the frequency image in this function
	 * basis of time domain coefficients. */

	H_Omega.Clear();

#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
}

void FilterVenster::drawFreqSpectrum() const
{
	/*! @notewrite in this function the code to draw the calculated frequency image in the
     * freq Domain graph window named "freqDomeinGrafiek" .*/

	const wxSize canvas(freqDomeinGrafiek->geefTekenVeldGrootte());
	const unsigned int numberOfFreqDomainPoints = FreqSpectrumPunten(taps);
	const auto stepSize = (Pi / numberOfFreqDomainPoints);

	/* toon het berekende venster in het frequentiedomein */
	freqDomeinGrafiek->maakSchoon();

	freqDomeinGrafiek->tekenAssenstelsel();

	const wxCoord veldEinde(-3 * canvas.GetHeight() / 4);

	const double schaalx = (1.0 * canvas.GetWidth()) / (Pi);
	const double schaaly = (3 * canvas.GetHeight() / (4 * fabs(H_Omega_max - H_Omega_min)));

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("BLUE")), 2, wxPENSTYLE_SOLID));

	/* Teken de spectrale componenten */
	double omega=0;
	for(Teller index=0; index < numberOfFreqDomainPoints; index++)
	{
		const wxCoord xcoord = static_cast<wxCoord>(omega * schaalx);
		const wxPoint begin(xcoord,veldEinde);
		const wxPoint einde(xcoord,(wxCoord)(schaaly*H_Omega[index]));
		const LijnStuk lijn(begin, einde);
//		wxLogDebug(wxT("H(%.2lf) = %lf"),omega,schaaly*(*(H_Omega+index)));
		freqDomeinGrafiek->tekenLijn(lijn);
		omega+=stepSize;
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREEN")), 3, wxPENSTYLE_SOLID));

	/* teken verticale lijnen op pi/6 */
	UInt32 omnummer=0;
	for(omega=0;omega<Pi;omega+=(Pi/6),omnummer++)
	{
		const wxCoord xcoord = static_cast<wxCoord>(omega * schaalx);
		freqDomeinGrafiek->tekenVerticaleLijn(xcoord);
		const wxPoint tekstpunt(xcoord, freqDomeinGrafiek->geefMaxY());
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%dpi/6"),omnummer), tekstpunt);
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREY")), 3, wxPENSTYLE_SOLID));
	/* teken horizontale lijnen op -10 db afstand */
	for (double dblijn=0;dblijn>H_Omega_min;dblijn-=10)
	{

		const wxCoord ycoord = static_cast<wxCoord>(dblijn*schaaly);
		freqDomeinGrafiek->tekenHorizontaleLijn(ycoord);
		const wxPoint tekstpunt(freqDomeinGrafiek->geefMaxX()-30,ycoord);
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%.0f dB"),dblijn), tekstpunt);
	}
	/* teken beginband en stopband */
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("PINK")), 3, wxPENSTYLE_SHORT_DASH));

	/* begin vd band */
	omega = 2*Pi*filterBegin/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn(static_cast<wxCoord>(omega * schaalx));
	/* eind vd band */
	omega = 2*Pi*filterEind/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn(static_cast<wxCoord>(omega * schaalx));

	const auto freqGrootte(freqDomeinGrafiek->GetClientSize());
	freqDomeinGrafiek->zetNormaleTekst(DemoTekst, wxPoint(freqGrootte.GetWidth()/16, -20));

}

Int16 FilterVenster::computeFixedPoint(const float flp) const
{
	/*! @note Calculate the conversion from floating point to fixed point in this function
	 * based on the setting in fipBitsSpinCtrl. */

#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	return(-1);
}

float FilterVenster::computeFloatingPoint(const Int16 fixp) const
{
	/*! @note Calculate the conversion from fixed point to floating point in this function
     * based on the setting in fipBitsSpinCtrl.*/

#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	return(-1);
}

#endif




void FilterVenster::tijdViewMuisBewegingHandler(wxMouseEvent &event)
{
#ifndef ExtraOpties
	event.Skip();
#else
	if (true == tijdDomeinCoords->IsEnabled())
	{
		
		const wxPoint mouseCoord(tijdDomeinGrafiek->converteerMuisPositie(const_cast<wxMouseEvent &>(event)));
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	}
#endif
}

void FilterVenster::freqViewMuisBewegingHandler(wxMouseEvent &event)
{
#ifndef ExtraOpties
	event.Skip();
#else
	if (true == freqDomeinCoords->IsEnabled())
	{
		
		const wxPoint muiscoord(freqDomeinGrafiek->converteerMuisPositie(const_cast<wxMouseEvent &>(event)));
#error “Dit deel van de software ontbreekt — this part of the software is missing.”
/* Beste leerling, dit deel van de software ontbreekt. Vul dit deel aan volgens de opdracht.  
   Dear student, this part of the software is missing. Complete this part accoording to the assignment.
*/
	}
#endif
}


void FilterVenster::tijdViewBinnenkomstHandler(wxMouseEvent &event)
{
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar == true));
	
	if (true == conditie)
	{
		wxLogDebug(_("Time graph entry."));
	}
	FindWindowById(BandBeginSliderID,this);
	tijdDomeinCoords->Enable(conditie);
}

void FilterVenster::tijdViewBuitengangHandler(wxMouseEvent &event)
{
	wxLogDebug(_("Time graph exit."));
	tijdDomeinCoords->Enable(false);
	tijdDomeinCoords->SetLabel(_("No coordinates"));
}

void FilterVenster::freqViewBinnenkomstHandler(wxMouseEvent &event)
{
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar == true));
	
	if (true == conditie)
	{
		wxLogDebug(_("Freq graph entry."));
	}
	
	freqDomeinCoords->Enable(conditie);
}

void FilterVenster::freqViewBuitengangHandler(wxMouseEvent &event)
{
	wxLogDebug(_("Freq graph exit."));
	freqDomeinCoords->Enable(false);
	freqDomeinCoords->SetLabel(_("No coordinates"));
}


/* Beste studenten, hier onder niets veranderen!
 * Dear students, do not alter anything beyond this point. */

/*
 * FilterVenster type definition
 */

IMPLEMENT_CLASS( FilterVenster, wxFrame )


/*
 * FilterVenster event table definition
 */

BEGIN_EVENT_TABLE( FilterVenster, wxFrame )

////@begin FilterVenster event table entries
				EVT_MENU( wxID_ABOUT, FilterVenster::OnAboutClick )
				EVT_MENU( wxID_SAVE, FilterVenster::OnSaveClick )
				EVT_UPDATE_UI( wxID_SAVE, FilterVenster::OnSaveUpdate )
				EVT_MENU( wxID_EXIT, FilterVenster::OnExitClick )
				EVT_UPDATE_UI( wxID_EXIT, FilterVenster::OnExitUpdate )
				EVT_MENU( BerekenFilterAktieID, FilterVenster::OnBerekenFilterAktieIDClick )
				EVT_UPDATE_UI( BerekenFilterAktieID, FilterVenster::OnBerekenFilterAktieIDUpdate )
				EVT_MENU( ExporteerFilterImpulseBeeldID, FilterVenster::OnExporteerFilterImpulseBeeldIDClick )
				EVT_UPDATE_UI( ExporteerFilterImpulseBeeldID, FilterVenster::OnExporteerFilterImpulseBeeldIDUpdate )
				EVT_MENU( ExporteerFreqBeeldID, FilterVenster::OnExporteerFreqBeeldIDClick )
				EVT_UPDATE_UI( ExporteerFreqBeeldID, FilterVenster::OnExporteerFreqBeeldIDUpdate )
				EVT_UPDATE_UI( ToonAnalogeFrekID, FilterVenster::OnToonAnalogeFrekIDUpdate )
				EVT_BUTTON( HANLogoID, FilterVenster::OnHANLogoIDClick )
				EVT_BUTTON( SampFreqID, FilterVenster::OnSampFreqIDClick )
				EVT_UPDATE_UI( SampFreqID, FilterVenster::OnSampFreqIDUpdate )
				EVT_BUTTON( FilterOrdeID, FilterVenster::OnFilterOrdeIDClick )
				EVT_UPDATE_UI( FilterOrdeID, FilterVenster::OnFilterOrdeIDUpdate )
				EVT_SPINCTRL( MaxVersterkingID, FilterVenster::OnMaxVersterkingIDUpdated )
				EVT_UPDATE_UI( MaxVersterkingID, FilterVenster::OnMaxVersterkingIDUpdate )
				EVT_CHOICE( VensterChoiceID, FilterVenster::OnVensterChoiceIDSelected )
				EVT_UPDATE_UI( VensterChoiceID, FilterVenster::OnVensterChoiceIDUpdate )
				EVT_SPINCTRL( BitKoderingID, FilterVenster::OnBitKoderingIDUpdated )
				EVT_UPDATE_UI( BitKoderingID, FilterVenster::OnBitKoderingIDUpdate )
				EVT_BUTTON( BerekenFilterID, FilterVenster::OnBerekenFilterAktieIDClick )
				EVT_UPDATE_UI( BerekenFilterID, FilterVenster::OnBerekenFilterAktieIDUpdate )
				EVT_CHECKBOX( ToonFilterKoeffsID, FilterVenster::OnToonFilterKoeffsIDClick )
				EVT_UPDATE_UI( ToonFilterKoeffsID, FilterVenster::OnToonFilterKoeffsIDUpdate )
				EVT_BUTTON( wxID_EXIT, FilterVenster::OnExitClick )
				EVT_UPDATE_UI( wxID_EXIT, FilterVenster::OnExitUpdate )
				EVT_SLIDER( BandBeginSliderID, FilterVenster::OnBandBeginSliderIDUpdated )
				EVT_UPDATE_UI( BandBeginSliderID, FilterVenster::OnBandBeginSliderIDUpdate )
				EVT_SLIDER( BandEindeSliderID, FilterVenster::OnBandEindeSliderIDUpdated )
				EVT_UPDATE_UI( BandEindeSliderID, FilterVenster::OnBandEindeSliderIDUpdate )
				EVT_UPDATE_UI( TestSignaalKeuzeID, FilterVenster::OnTestSignaalKeuzeIDUpdate )
				EVT_SLIDER( TestSignaalFrekID, FilterVenster::OnTestSignaalFrekIDUpdated )
				EVT_UPDATE_UI( TestSignaalFrekID, FilterVenster::OnTestSignaalFrekIDUpdate )
				EVT_SLIDER( TestSignaalAmplitudeID, FilterVenster::OnTestSignaalAmplitudeIDUpdated )
				EVT_UPDATE_UI( TestSignaalAmplitudeID, FilterVenster::OnTestSignaalAmplitudeIDUpdate )
				EVT_UPDATE_UI( TekenOrigSignaalID, FilterVenster::OnTekenOrigSignaalIDUpdate )
				EVT_UPDATE_UI( TekenSplineID, FilterVenster::OnTekenSplineIDUpdate )
				EVT_TOGGLEBUTTON( FilterTestID, FilterVenster::OnFilterTestIDClick )
				EVT_UPDATE_UI( FilterTestID, FilterVenster::OnFilterTestIDUpdate )
////@end FilterVenster event table entries

END_EVENT_TABLE()


/*
 * FilterVenster constructors
 */
FilterVenster::FilterVenster()
{
	Init();
	wxASSERT(0);
}

FilterVenster::FilterVenster(DesktopApp &app, wxWindowID id,
                             const wxString& caption,
                             const wxPoint& pos,
                             const wxSize& size, long style) :
		FilterDesignerBasis(),
		filterConfig(app.geefAppConfig()),    /* verkrijg de globale config pointer */
		klok(this, KlokVerlopenID),
		DemoTekst(
#ifndef OnderwijsOntwikkeling
				_("Developer")+wxT(": ")+wxT(GebruikerNaam))
#else
				_("Demo version"))
#endif
{
	Init();
	Create(nullptr, id, caption, pos, size, style);
	
	/* koppel de timer event handmatig. */
	Connect(KlokVerlopenID, wxEVT_TIMER,
	        wxTimerEventHandler(FilterVenster::klokVerlopenHandler),
	        nullptr, this);
	
	wxASSERT(nullptr != filterConfig);
	
	/* lees filter voorkeurswaarden in */
	filterConfig->SetPath(wxT("/Configuratie/Filter"));
	
	int leeswaarde;
	
	filterConfig->Read(wxT("Sampling_Frequentie"), (int*)&sampFreq, 500);
	filterConfig->Read(wxT("Startband"), (int*)&filterBegin, 100);
	filterConfig->Read(wxT("Stopband"), (int*)&filterEind, 140);
	
	filterConfig->Read(wxT("AantalTaps"), &leeswaarde, 61);
	taps = leeswaarde;
	filterConfig->Read(wxT("Filterorde"), &leeswaarde, 30);
	orde = leeswaarde;
	filterConfig->Read(wxT("MaxVersterking"), &leeswaarde, 0);
	maxVersterkingSpinCtrl->SetValue(leeswaarde);
	
	filterConfig->Read(wxT("VensterKeuze"), &leeswaarde, 0);
	vensterChoice->SetSelection(leeswaarde);
	filterConfig->Read(wxT("FixedPointBits"), &leeswaarde, 5);
	fipBitsSpinCtrl->SetValue(leeswaarde);
	
	filterConfig->Read(wxT("TestSignaal"), (int*)&leeswaarde, 0);
	testSignaalChoice->SetSelection(leeswaarde);
	
	filterConfig->Read(wxT("Testfreq"), (int*)&testFreq, 20);
	filterConfig->Read(wxT("Testampl"), (int*)&leeswaarde, 1024);
	testAmplitude = leeswaarde;
	filterConfig->Read(wxT("TestOrig"), (bool*)&testOrig, false);
	filterConfig->Read(wxT("TestSpline"), (bool*)&testSpline, false);
	filterConfig->Read(wxT("Tooncoefficienten"), (bool*)&toonCoeffs, false);
	
	filterConfig->SetPath(wxT("/Configuratie/Paden"));
	
	const wxFileName standaard(wxGetHomeDir(), wxT("filter.h"));
	
	filterConfig->Read(wxT("DataPad"), &dataPad, standaard.GetFullPath());
	
	auto* label = dynamic_cast<wxStaticText*>(FindWindowById(SampFreqTextID, this));
	wxString tekst = wxString::Format(wxT("%d Hz"), sampFreq);
	auto* check = dynamic_cast<wxCheckBox*>(FindWindowById(TekenOrigSignaalID, this));
	
	
	label->SetLabel(tekst);
	
	bandBeginSlider->SetRange(0, (sampFreq / 2));
	wxLogDebug(wxT("Begin=%d"), filterBegin);
	bandBeginSlider->SetValue(filterBegin);
	
	bandEindeSlider->SetRange(1, (sampFreq / 2));
	wxLogDebug(wxT("Begin=%d"), filterEind);
	bandEindeSlider->SetValue(filterEind);
	
	label = static_cast<wxStaticText*>(FindWindowById(FilterOrdeTextID, this));
	tekst = wxString::Format(wxT("%d taps"), taps);
	label->SetLabel(tekst);
	
	testSignaalSlider->SetRange(1, 4 * sampFreq);
	testSignaalSlider->SetValue(testFreq);
	testSignaalAmplitudeSlider->SetValue(testAmplitude);
	
	check->SetValue(testOrig);
	check = static_cast<wxCheckBox*>(FindWindowById(TekenSplineID, this));
	check->SetValue(testSpline);
	check = static_cast<wxCheckBox*>(FindWindowById(ToonFilterKoeffsID, this));
	check->SetValue(toonCoeffs);
	
	label = static_cast<wxStaticText*>(FindWindowById(FilterOrdeTextID, this));
	tekst = wxString::Format(_("Orde = %d (%d taps)"), orde, taps);
	label->SetLabel(tekst);
	
	tijdDomeinGrafiek->zetAssenPen(axisPen);
	tijdDomeinGrafiek->zetTekenPen(timeDomainPen);
	
	freqDomeinGrafiek->zetAssenPen(axisPen);
	freqDomeinGrafiek->zetTekenPen(freqDomainPen);
	
	tijdDomeinGrafiek->zetOorsprongMidden();
	freqDomeinGrafiek->zetOorsprong(wxRealPoint(0, 0.75));
	testGrafiek->zetOorsprong(wxRealPoint(0, 0.5));
	
	const auto testGrootte(testGrafiek->GetClientSize());
	testGrafiek->zetGroteTekst(DemoTekst, wxPoint(0, testGrootte.GetHeight() / 2));
}



/*
 * FilterVenster destructor
 */

FilterVenster::~FilterVenster()
{
	auto applikatie = reinterpret_cast<FirFilterKlasse *>(wxTheApp);
	applikatie->bewaarHoofdVensterGrootte();
	
	/* Initialiseer de configuratie */
	/* lees filter voorkeurswaarden in */
	filterConfig->SetPath(wxT("/Configuratie/Filter"));
	
	filterConfig->Write(wxT("Sampling_Frequentie"),sampFreq);
	filterConfig->Write(wxT("Startband"),filterBegin);
	filterConfig->Write(wxT("Stopband"),filterEind);
	filterConfig->Write(wxT("AantalTaps"),static_cast<int>(taps));
	filterConfig->Write(wxT("Filterorde"),static_cast<int>(orde));
	filterConfig->Write(wxT("MaxVersterking"),maxVersterkingSpinCtrl->GetValue());
	filterConfig->Write(wxT("VensterKeuze"),vensterChoice->GetSelection());
	filterConfig->Write(wxT("FixedPointBits"),fipBitsSpinCtrl->GetValue());
	
	filterConfig->Write(wxT("TestSignaal"),testSignaalChoice->GetSelection());
	filterConfig->Write(wxT("Testfreq"),(int )testFreq);
	filterConfig->Write(wxT("Testampl"),static_cast<int>(testAmplitude));
	
	filterConfig->Write(wxT("TestOrig"),(bool )testOrig);
	filterConfig->Write(wxT("TestSpline"),(bool )testSpline);
	filterConfig->Write(wxT("Tooncoefficienten"),toonCoeffs);
	
	filterConfig->SetPath(wxT("/Configuratie/Paden"));
	
	filterConfig->Write(wxT("DataPad"),dataPad);
}

/*
 * FilterVenster creator
 */

bool FilterVenster::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin FilterVenster creation
	wxFrame::Create( parent, id, caption, pos, size, style );
	
	CreateControls();
	if (GetSizer())
	{
		GetSizer()->SetSizeHints(this);
	}
////@end FilterVenster creation
	return true;
}



/*
 * Member initialisation
 */

void FilterVenster::Init()
{
////@begin FilterVenster member initialisation
	tijdDomeinGrafiek = NULL;
	tijdDomeinCoords = NULL;
	freqDomeinGrafiek = NULL;
	freqDomeinCoords = NULL;
	toonAnalogeFrequentiesCheckBox = NULL;
	testGrafiek = NULL;
	sampFreqButton = NULL;
	sampFreqText = NULL;
	ordeButton = NULL;
	filterOrdeText = NULL;
	maxVersterkingSpinCtrl = NULL;
	vensterChoice = NULL;
	fipBitsSpinCtrl = NULL;
	berekenFilterKnop = NULL;
	toonfilterCoeffsCB = NULL;
	bandBeginSlider = NULL;
	bandEindeSlider = NULL;
	testSignaalChoice = NULL;
	testSignaalSlider = NULL;
	testSignaalAmplitudeSlider = NULL;
	tekenOrigineelCheckBox = NULL;
	tekenSplineCheckBox = NULL;
	filterTestButton = NULL;
////@end FilterVenster member initialisation
}


/*
 * Control creation for FilterVenster
 */

void FilterVenster::CreateControls()
{
////@begin FilterVenster content construction
	FilterVenster* itemFrame1 = this;
	
	wxMenuBar* menuBar = new wxMenuBar;
	wxMenu* itemMenu3 = new wxMenu;
	itemMenu3->Append(wxID_ABOUT, _("About"), wxEmptyString, wxITEM_NORMAL);
	itemMenu3->Append(wxID_SAVE, _("Write a C/CPP Header file"), wxEmptyString, wxITEM_NORMAL);
	itemMenu3->Append(wxID_EXIT, _("Quit\tCtrl+Q"), wxEmptyString, wxITEM_NORMAL);
	menuBar->Append(itemMenu3, _("Bestand"));
	wxMenu* itemMenu6 = new wxMenu;
	itemMenu6->Append(BerekenFilterAktieID, _("Calculate Filter\tCtrl+B"), wxEmptyString, wxITEM_NORMAL);
	itemMenu6->Append(ExporteerFilterImpulseBeeldID, _("Export the time domain image\tCtrl+R"), wxEmptyString, wxITEM_NORMAL);
	itemMenu6->Append(ExporteerFreqBeeldID, _("Export the frequency domain image\tCtrl+E"), wxEmptyString, wxITEM_NORMAL);
	menuBar->Append(itemMenu6, _("Filter"));
	itemFrame1->SetMenuBar(menuBar);
	
	wxBoxSizer* itemBoxSizer11 = new wxBoxSizer(wxHORIZONTAL);
	itemFrame1->SetSizer(itemBoxSizer11);
	
	wxPanel* itemPanel12 = new wxPanel( itemFrame1, hoofdPaneel, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
	itemPanel12->SetExtraStyle(wxWS_EX_VALIDATE_RECURSIVELY);
	itemPanel12->SetBackgroundColour(wxColour(47, 180, 255));
	itemBoxSizer11->Add(itemPanel12, 1, wxGROW|wxALL, 0);
	
	wxBoxSizer* itemBoxSizer1 = new wxBoxSizer(wxVERTICAL);
	itemPanel12->SetSizer(itemBoxSizer1);
	
	wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer1->Add(itemBoxSizer2, 0, wxALIGN_CENTER_HORIZONTAL, 0);
	
	wxStaticBox* itemStaticBoxSizer3Static = new wxStaticBox(itemPanel12, wxID_ANY, _("Time domain filter impulse response"));
	wxStaticBoxSizer* itemStaticBoxSizer3 = new wxStaticBoxSizer(itemStaticBoxSizer3Static, wxVERTICAL);
	itemBoxSizer2->Add(itemStaticBoxSizer3, 1, wxGROW, 0);
	
	tijdDomeinGrafiek = new GrafiekVenster( itemStaticBoxSizer3->GetStaticBox(), TijdDomeinGrafiekID, wxDefaultPosition, wxSize(400, 199), 0 );
	itemStaticBoxSizer3->Add(tijdDomeinGrafiek, 0, wxGROW|wxALL, 2);
	
	tijdDomeinCoords = new wxStaticText( itemStaticBoxSizer3->GetStaticBox(), TijdDomeinKoordsID, _("Time domain coordinates (Mouse over window)"), wxDefaultPosition, wxDefaultSize, 0 );
	tijdDomeinCoords->Enable(false);
	itemStaticBoxSizer3->Add(tijdDomeinCoords, 0, wxGROW|wxALL, 3);
	
	wxStaticBox* itemStaticBoxSizer7Static = new wxStaticBox(itemPanel12, wxID_ANY, _("Frequency domain representation"));
	wxStaticBoxSizer* itemStaticBoxSizer7 = new wxStaticBoxSizer(itemStaticBoxSizer7Static, wxVERTICAL);
	itemBoxSizer2->Add(itemStaticBoxSizer7, 1, wxGROW, 0);
	
	freqDomeinGrafiek = new GrafiekVenster( itemStaticBoxSizer7->GetStaticBox(), FreqDomeinGrafiekID, wxDefaultPosition, wxSize(400, 199), 0 );
	itemStaticBoxSizer7->Add(freqDomeinGrafiek, 0, wxGROW|wxALL, 2);
	
	wxBoxSizer* itemBoxSizer9 = new wxBoxSizer(wxVERTICAL);
	itemStaticBoxSizer7->Add(itemBoxSizer9, 0, wxGROW, 0);
	
	freqDomeinCoords = new wxStaticText( itemStaticBoxSizer7->GetStaticBox(), FrekDomeinKoordsID, _("Frequency domain coordinates (Mouse over window)"), wxDefaultPosition, wxDefaultSize, 0 );
	freqDomeinCoords->Enable(false);
	itemBoxSizer9->Add(freqDomeinCoords, 0, wxGROW|wxALL, 3);
	
	toonAnalogeFrequentiesCheckBox = new wxCheckBox( itemStaticBoxSizer7->GetStaticBox(), ToonAnalogeFrekID, _("Show analogue frequencies"), wxDefaultPosition, wxDefaultSize, 0 );
	toonAnalogeFrequentiesCheckBox->SetValue(false);
	itemBoxSizer9->Add(toonAnalogeFrequentiesCheckBox, 0, wxALIGN_LEFT|wxALL, 3);
	
	wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer1->Add(itemBoxSizer4, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);
	
	wxBitmapButton* itemBitmapButton5 = new wxBitmapButton( itemPanel12, HANLogoID, itemFrame1->GetBitmapResource(wxT("../../../DesktopBasis/gemeenschappelijk/logos/hanlogo_klein.png")), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW );
	if (FilterVenster::ShowToolTips())
		itemBitmapButton5->SetToolTip(_("Discover HAN Embedded Systems Engineering!"));
	itemBoxSizer4->Add(itemBitmapButton5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 0);
	
	wxStaticBox* itemStaticBoxSizer6Static = new wxStaticBox(itemPanel12, wxID_ANY, _("Test results visualization"));
	wxStaticBoxSizer* itemStaticBoxSizer6 = new wxStaticBoxSizer(itemStaticBoxSizer6Static, wxHORIZONTAL);
	itemBoxSizer4->Add(itemStaticBoxSizer6, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
	
	testGrafiek = new GrafiekVenster( itemStaticBoxSizer6->GetStaticBox(), TestGrafiekID, wxDefaultPosition, wxSize(800, 199), 0 );
	itemStaticBoxSizer6->Add(testGrafiek, 1, wxGROW|wxALL, 0);
	
	wxBoxSizer* itemBoxSizer19 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer1->Add(itemBoxSizer19, 0, wxALIGN_CENTER_HORIZONTAL, 0);
	
	wxStaticBox* itemStaticBoxSizer4Static = new wxStaticBox(itemPanel12, wxID_ANY, _("Filter parameters"));
	wxStaticBoxSizer* itemStaticBoxSizer4 = new wxStaticBoxSizer(itemStaticBoxSizer4Static, wxVERTICAL);
	itemBoxSizer19->Add(itemStaticBoxSizer4, 0, wxGROW, 0);
	
	wxBoxSizer* itemBoxSizer7 = new wxBoxSizer(wxHORIZONTAL);
	itemStaticBoxSizer4->Add(itemBoxSizer7, 1, wxGROW, 0);
	
	wxBoxSizer* itemBoxSizer8 = new wxBoxSizer(wxVERTICAL);
	itemBoxSizer7->Add(itemBoxSizer8, 1, wxGROW, 0);
	
	wxFlexGridSizer* itemFlexGridSizer9 = new wxFlexGridSizer(5, 2, 3, 3);
	itemBoxSizer8->Add(itemFlexGridSizer9, 0, wxGROW|wxALL, 1);
	
	sampFreqButton = new wxButton( itemStaticBoxSizer4->GetStaticBox(), SampFreqID, _("Sampling frequency (Hz)"), wxDefaultPosition, wxDefaultSize, 0 );
	sampFreqButton->SetDefault();
	itemFlexGridSizer9->Add(sampFreqButton, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	sampFreqText = new wxStaticText( itemStaticBoxSizer4->GetStaticBox(), SampFreqTextID, _("undetermined"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(sampFreqText, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	ordeButton = new wxButton( itemStaticBoxSizer4->GetStaticBox(), FilterOrdeID, _("Filter order"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(ordeButton, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	filterOrdeText = new wxStaticText( itemStaticBoxSizer4->GetStaticBox(), FilterOrdeTextID, _("undetermined"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(filterOrdeText, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	wxStaticText* itemStaticText15 = new wxStaticText( itemStaticBoxSizer4->GetStaticBox(), wxID_STATIC, _("Supplemental filter amplification (dB) :"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(itemStaticText15, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL, 0);
	
	maxVersterkingSpinCtrl = new wxSpinCtrl( itemStaticBoxSizer4->GetStaticBox(), MaxVersterkingID, wxT("0"), wxDefaultPosition, wxDefaultSize, 0, -30, 30, 0 );
	itemFlexGridSizer9->Add(maxVersterkingSpinCtrl, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	wxStaticText* itemStaticText17 = new wxStaticText( itemStaticBoxSizer4->GetStaticBox(), wxID_ANY, _("Window applied :"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(itemStaticText17, 0, wxALIGN_LEFT|wxALIGN_TOP, 0);
	
	wxArrayString vensterChoiceStrings;
	vensterChoiceStrings.Add(_("Rectangle"));
	vensterChoiceStrings.Add(_("Triangle"));
	vensterChoiceStrings.Add(_("Hamming"));
	vensterChoice = new wxChoice( itemStaticBoxSizer4->GetStaticBox(), VensterChoiceID, wxDefaultPosition, wxDefaultSize, vensterChoiceStrings, 0 );
	vensterChoice->SetStringSelection(_("Rectangle"));
	itemFlexGridSizer9->Add(vensterChoice, 0, wxGROW|wxALIGN_CENTER_VERTICAL, 0);
	
	wxStaticText* itemStaticText19 = new wxStaticText( itemStaticBoxSizer4->GetStaticBox(), wxID_ANY, _("Number of bits in coding :"), wxDefaultPosition, wxDefaultSize, 0 );
	itemFlexGridSizer9->Add(itemStaticText19, 0, wxALIGN_LEFT|wxALIGN_TOP, 0);
	
	fipBitsSpinCtrl = new wxSpinCtrl( itemStaticBoxSizer4->GetStaticBox(), BitKoderingID, wxT("3"), wxDefaultPosition, wxDefaultSize, 0, 3, 16, 3 );
	itemFlexGridSizer9->Add(fipBitsSpinCtrl, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 0);
	
	wxBoxSizer* itemBoxSizer21 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer8->Add(itemBoxSizer21, 0, wxGROW|wxALL, 2);
	
	berekenFilterKnop = new wxButton( itemStaticBoxSizer4->GetStaticBox(), BerekenFilterID, _("Calculate filter"), wxDefaultPosition, wxDefaultSize, 0 );
	berekenFilterKnop->SetDefault();
	berekenFilterKnop->SetFont(wxFont(16, wxFONTFAMILY_SWISS, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false, wxT("Tahoma")));
	berekenFilterKnop->Enable(false);
	itemBoxSizer21->Add(berekenFilterKnop, 0, wxGROW|wxALL, 3);
	
	toonfilterCoeffsCB = new wxCheckBox( itemStaticBoxSizer4->GetStaticBox(), ToonFilterKoeffsID, _("Dump coefficients"), wxDefaultPosition, wxDefaultSize, 0 );
	toonfilterCoeffsCB->SetValue(true);
	itemBoxSizer21->Add(toonfilterCoeffsCB, 0, wxALIGN_CENTER_VERTICAL|wxALL, 3);
	
	wxButton* itemButton1 = new wxButton( itemStaticBoxSizer4->GetStaticBox(), wxID_EXIT, _("&Quit"), wxDefaultPosition, wxDefaultSize, 0 );
	itemBoxSizer8->Add(itemButton1, 0, wxGROW|wxALL, 2);
	
	wxBoxSizer* itemBoxSizer24 = new wxBoxSizer(wxVERTICAL);
	itemBoxSizer7->Add(itemBoxSizer24, 0, wxGROW, 0);
	
	wxStaticBox* itemStaticBoxSizer25Static = new wxStaticBox(itemStaticBoxSizer4->GetStaticBox(), wxID_ANY, _("Band pass begin (Hz)"));
	wxStaticBoxSizer* itemStaticBoxSizer25 = new wxStaticBoxSizer(itemStaticBoxSizer25Static, wxVERTICAL);
	itemBoxSizer24->Add(itemStaticBoxSizer25, 0, wxGROW|wxALL, 6);
	
	bandBeginSlider = new wxSlider( itemStaticBoxSizer25->GetStaticBox(), BandBeginSliderID, 600, 400, 800, wxDefaultPosition, wxDefaultSize, wxSL_HORIZONTAL|wxSL_AUTOTICKS|wxSL_LABELS );
	bandBeginSlider->Enable(false);
	itemStaticBoxSizer25->Add(bandBeginSlider, 1, wxGROW, 0);
	
	wxStaticBox* itemStaticBoxSizer27Static = new wxStaticBox(itemStaticBoxSizer4->GetStaticBox(), wxID_ANY, _("Band pass end (Hz)"));
	wxStaticBoxSizer* itemStaticBoxSizer27 = new wxStaticBoxSizer(itemStaticBoxSizer27Static, wxVERTICAL);
	itemBoxSizer24->Add(itemStaticBoxSizer27, 0, wxGROW|wxALL, 6);
	
	bandEindeSlider = new wxSlider( itemStaticBoxSizer27->GetStaticBox(), BandEindeSliderID, 600, 400, 800, wxDefaultPosition, wxDefaultSize, wxSL_HORIZONTAL|wxSL_AUTOTICKS|wxSL_LABELS );
	bandEindeSlider->Enable(false);
	itemStaticBoxSizer27->Add(bandEindeSlider, 1, wxGROW, 0);
	
	wxStaticBox* itemStaticBoxSizer1Static = new wxStaticBox(itemPanel12, wxID_ANY, _("Filter test"));
	wxStaticBoxSizer* itemStaticBoxSizer1 = new wxStaticBoxSizer(itemStaticBoxSizer1Static, wxVERTICAL);
	itemBoxSizer19->Add(itemStaticBoxSizer1, 0, wxGROW, 0);
	
	wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
	itemStaticBoxSizer1->Add(itemBoxSizer3, 0, wxGROW, 0);
	
	wxArrayString testSignaalChoiceStrings;
	testSignaalChoiceStrings.Add(_("Cosine"));
	testSignaalChoiceStrings.Add(_("Square wave"));
	testSignaalChoiceStrings.Add(_("Impulse"));
	testSignaalChoiceStrings.Add(_("Step"));
	testSignaalChoice = new wxChoice( itemStaticBoxSizer1->GetStaticBox(), TestSignaalKeuzeID, wxDefaultPosition, wxDefaultSize, testSignaalChoiceStrings, 0 );
	testSignaalChoice->SetStringSelection(_("Cosine"));
	itemBoxSizer3->Add(testSignaalChoice, 1, wxGROW|wxALL, 6);
	
	wxBoxSizer* itemBoxSizer5 = new wxBoxSizer(wxVERTICAL);
	itemStaticBoxSizer1->Add(itemBoxSizer5, 0, wxALIGN_LEFT, 0);
	
	wxBoxSizer* itemBoxSizer6 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer5->Add(itemBoxSizer6, 0, wxALIGN_LEFT, 0);
	
	wxStaticBox* itemStaticBoxSizer8Static = new wxStaticBox(itemStaticBoxSizer1->GetStaticBox(), wxID_ANY, _("Test Signal frequency"));
	wxStaticBoxSizer* itemStaticBoxSizer8 = new wxStaticBoxSizer(itemStaticBoxSizer8Static, wxVERTICAL);
	itemBoxSizer6->Add(itemStaticBoxSizer8, 0, wxALIGN_TOP|wxALL, 6);
	
	testSignaalSlider = new wxSlider( itemStaticBoxSizer8->GetStaticBox(), TestSignaalFrekID, 500, 0, 1600, wxDefaultPosition, wxDefaultSize, wxSL_HORIZONTAL|wxSL_AUTOTICKS|wxSL_LABELS );
	itemStaticBoxSizer8->Add(testSignaalSlider, 1, wxGROW|wxBOTTOM, 10);
	
	wxBoxSizer* itemBoxSizer10 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer6->Add(itemBoxSizer10, 0, wxALIGN_TOP, 0);
	
	wxStaticBox* itemStaticBoxSizer11Static = new wxStaticBox(itemStaticBoxSizer1->GetStaticBox(), wxID_ANY, _("Test Signal amplitude"));
	wxStaticBoxSizer* itemStaticBoxSizer11 = new wxStaticBoxSizer(itemStaticBoxSizer11Static, wxVERTICAL);
	itemBoxSizer10->Add(itemStaticBoxSizer11, 1, wxALIGN_TOP|wxALL, 6);
	
	testSignaalAmplitudeSlider = new wxSlider( itemStaticBoxSizer11->GetStaticBox(), TestSignaalAmplitudeID, 1000, 0, 32767, wxDefaultPosition, wxDefaultSize, wxSL_HORIZONTAL|wxSL_AUTOTICKS|wxSL_LABELS );
	itemStaticBoxSizer11->Add(testSignaalAmplitudeSlider, 1, wxGROW|wxBOTTOM, 10);
	
	wxBoxSizer* itemBoxSizer13 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer5->Add(itemBoxSizer13, 0, wxGROW, 0);
	
	tekenOrigineelCheckBox = new wxCheckBox( itemStaticBoxSizer1->GetStaticBox(), TekenOrigSignaalID, _("Show test signal"), wxDefaultPosition, wxDefaultSize, 0 );
	tekenOrigineelCheckBox->SetValue(false);
	itemBoxSizer13->Add(tekenOrigineelCheckBox, 0, wxALIGN_TOP|wxALL, 2);
	
	tekenSplineCheckBox = new wxCheckBox( itemStaticBoxSizer1->GetStaticBox(), TekenSplineID, _("Draw interpolation spline"), wxDefaultPosition, wxDefaultSize, 0 );
	tekenSplineCheckBox->SetValue(true);
	itemBoxSizer13->Add(tekenSplineCheckBox, 0, wxALIGN_TOP|wxALL, 2);
	
	filterTestButton = new wxToggleButton( itemStaticBoxSizer1->GetStaticBox(), FilterTestID, _("Start Filter Test"), wxDefaultPosition, wxDefaultSize, 0 );
	filterTestButton->SetValue(false);
	itemStaticBoxSizer1->Add(filterTestButton, 0, wxGROW|wxALL, 2);
	
	// Connect events and objects
	tijdDomeinGrafiek->Connect(TijdDomeinGrafiekID, wxEVT_MOTION, wxMouseEventHandler(FilterVenster::OnMotion), NULL, this);
	tijdDomeinGrafiek->Connect(TijdDomeinGrafiekID, wxEVT_ENTER_WINDOW, wxMouseEventHandler(FilterVenster::OnEnterWindow), NULL, this);
	tijdDomeinGrafiek->Connect(TijdDomeinGrafiekID, wxEVT_LEAVE_WINDOW, wxMouseEventHandler(FilterVenster::OnLeaveWindow), NULL, this);
	freqDomeinGrafiek->Connect(FreqDomeinGrafiekID, wxEVT_MOTION, wxMouseEventHandler(FilterVenster::OnMotion), NULL, this);
	freqDomeinGrafiek->Connect(FreqDomeinGrafiekID, wxEVT_ENTER_WINDOW, wxMouseEventHandler(FilterVenster::OnEnterWindow), NULL, this);
	freqDomeinGrafiek->Connect(FreqDomeinGrafiekID, wxEVT_LEAVE_WINDOW, wxMouseEventHandler(FilterVenster::OnLeaveWindow), NULL, this);
////@end FilterVenster content construction
}


/*
 * Should we show tooltips?
 */

bool FilterVenster::ShowToolTips()
{
	return true;
}

/*
 * Get bitmap resources
 */

wxBitmap FilterVenster::GetBitmapResource( const wxString& name )
{
	// Bitmap retrieval
////@begin FilterVenster bitmap retrieval
	wxUnusedVar(name);
	if (name == wxT("../../../DesktopBasis/gemeenschappelijk/logos/hanlogo_klein.png"))
	{
		wxMemoryInputStream memStream(hanlogo_klein_png, sizeof(hanlogo_klein_png));
		wxBitmap bitmap(wxImage(memStream, wxBITMAP_TYPE_ANY, -1), -1);
		return bitmap;
	}
	return wxNullBitmap;
////@end FilterVenster bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon FilterVenster::GetIconResource( const wxString& name )
{
	// Icon retrieval
////@begin FilterVenster icon retrieval
	wxUnusedVar(name);
	return wxNullIcon;
////@end FilterVenster icon retrieval
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for BerekenFilterAktieID
 */

void FilterVenster::OnBerekenFilterAktieIDClick( wxCommandEvent& event )
{
#ifdef InterfaceTaalNederlands
	berekenFilter(event);
#else
	computeFilter(event);
#endif
}


/*
 * wxEVT_UPDATE_UI event handler for BerekenFilterAktieID
 */

void FilterVenster::OnBerekenFilterAktieIDUpdate( wxUpdateUIEvent& event )
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar != true));
	
	event.Enable(conditie);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for SampFreqID
 */

void FilterVenster::OnSampFreqIDClick( wxCommandEvent& event )
{
	wxNumberEntryDialog dialoog(this,
	                            _("Specify the sampling frequency in Hz."),
	                            _("Frequency:"),
	                            _("The FIR filter system sampling frequency"),
	                            (int)sampFreq,
	                            1,
	                            64000);
	
	if (wxID_OK == dialoog.ShowModal())
	{
		wxStaticText *label = static_cast<wxStaticText*>(FindWindowById(SampFreqTextID, this));
		wxSlider *slider;
		
		sampFreq = dialoog.GetValue();
		wxString tekst = wxString::Format(wxT("%d Hz"),sampFreq);
		label->SetLabel(tekst);
		
		/* reset begin en eind van de band als de frequenties niet meer passen */
		if (filterEind > sampFreq)
		{
			filterBegin = sampFreq / 8;
			filterEind = 3 * sampFreq / 8;
		}
		
		slider = static_cast<wxSlider*>(FindWindowById(BandBeginSliderID, this));
		slider->SetRange(0,(sampFreq/2));
		slider->SetValue(filterBegin);
		
		slider = static_cast<wxSlider*>(FindWindowById(BandEindeSliderID, this));
		slider->SetRange(1,(sampFreq/2));
		slider->SetValue(filterEind);
		
		slider = static_cast<wxSlider*>(FindWindowById(TestSignaalFrekID, this));
		slider->SetRange(1,sampFreq);
		
		/* reset test freq als deze buiten het bereik valt */
		if (testFreq>(sampFreq))
			testFreq = sampFreq/4;
		
		slider->SetValue(testFreq);
		
		berekeningKlaar = false;
	}
}


/*
 * wxEVT_UPDATE_UI event handler for SampFreqID
 */

void FilterVenster::OnSampFreqIDUpdate( wxUpdateUIEvent& event )
{
	const bool nietInTest = (testSituatie==false);
	event.Enable(true==nietInTest);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for FilterOrdeID
 */

void FilterVenster::OnFilterOrdeIDClick( wxCommandEvent& event )
{
	
	wxNumberEntryDialog dialoog(this,
	                            _("Specify the order of the filter in number of taps."),
	                            _("Filter order:"),
	                            _("Taps in the FIR filter system"),
	                            ((taps-1)/2),1,200);
	
	if (wxID_OK == dialoog.ShowModal())
	{
		auto * const label = static_cast<wxStaticText*>(FindWindowById(FilterOrdeTextID, this));
		
		orde = static_cast<UInt16>(dialoog.GetValue());
		taps = 2*orde + 1;
		
		const wxString tekst = wxString::Format(_("Orde = %d (%d taps)"),orde,taps);
		label->SetLabel(tekst);
		
		berekeningKlaar = false;
	}
}


/*
 * wxEVT_UPDATE_UI event handler for FilterOrdeID
 */

void FilterVenster::OnFilterOrdeIDUpdate( wxUpdateUIEvent& event )
{
	const bool nietInTest = (testSituatie==false);
	event.Enable(true==nietInTest);
}


/*
 * wxEVT_COMMAND_SPINCTRL_UPDATED event handler for MaxVersterkingID
 */

void FilterVenster::OnMaxVersterkingIDUpdated( wxSpinEvent& event )
{
	berekeningKlaar = false;
}


/*
 * wxEVT_UPDATE_UI event handler for MaxVersterkingID
 */

void FilterVenster::OnMaxVersterkingIDUpdate( wxUpdateUIEvent& event )
{
	const bool nietInTest = (testSituatie==false);
	event.Enable(true==nietInTest);
}


/*
 * wxEVT_COMMAND_CHOICE_SELECTED event handler for VensterChoiceID
 */

void FilterVenster::OnVensterChoiceIDSelected( wxCommandEvent& event )
{
	berekeningKlaar = false;
}


/*
 * wxEVT_UPDATE_UI event handler for VensterChoiceID
 */

void FilterVenster::OnVensterChoiceIDUpdate( wxUpdateUIEvent& event )
{
	const bool nietInTest = (testSituatie==false);
	event.Enable(true==nietInTest);
}


/*
 * wxEVT_COMMAND_SPINCTRL_UPDATED event handler for BitKoderingID
 */

void FilterVenster::OnBitKoderingIDUpdated( wxSpinEvent& event )
{
	berekeningKlaar = false;
}


/*
 * wxEVT_UPDATE_UI event handler for BitKoderingID
 */

void FilterVenster::OnBitKoderingIDUpdate( wxUpdateUIEvent& event )
{
	const bool nietInTest = (testSituatie==false);
	event.Enable(true==nietInTest);
}




/*
 * wxEVT_COMMAND_SLIDER_UPDATED event handler for BandBeginSliderID
 */

void FilterVenster::OnBandBeginSliderIDUpdated( wxCommandEvent& event )
{
	if (false == bandControleRoutine(event))
	{
		auto * slider = reinterpret_cast<wxSlider *>(FindWindowById(BandBeginSliderID,this));
		
		const Frequentie freq = slider->GetValue();
		
		filterBegin = freq;
		beginPuntBepaald = true;
		berekeningKlaar = false;
	}
}


/*
 * wxEVT_UPDATE_UI event handler for BandBeginSliderID
 */

void FilterVenster::OnBandBeginSliderIDUpdate( wxUpdateUIEvent& event )
{
	const bool bandMag = ((testSituatie != true) && (sampFreq != 0) && (taps != 0));
	
	event.Enable(true == bandMag);
}


/*
 * wxEVT_COMMAND_SLIDER_UPDATED event handler for BandEindeSliderID
 */

void FilterVenster::OnBandEindeSliderIDUpdated( wxCommandEvent& event )
{
	if (false == bandControleRoutine(event))
	{
		auto * slider = reinterpret_cast<wxSlider *>(FindWindowById(BandEindeSliderID,this));
		
		const Frequentie freq = slider->GetValue();
		
		filterEind = freq;
		eindPuntBepaald = true;
		berekeningKlaar = false;
	}
}


/*
 * wxEVT_UPDATE_UI event handler for BandEindeSliderID
 */

void FilterVenster::OnBandEindeSliderIDUpdate( wxUpdateUIEvent& event )
{
	const bool bandMag = ((testSituatie != true) && (sampFreq != 0) && (taps != 0));
	
	event.Enable(true == bandMag);
}

bool FilterVenster::bandControleRoutine(wxCommandEvent &event) const
{
	auto * const beginSlider = dynamic_cast<wxSlider *>(FindWindowById(BandBeginSliderID,this));
	auto * eindeSlider = dynamic_cast<wxSlider *>(FindWindowById(BandEindeSliderID, this));
	
	const bool fout = (beginSlider->GetValue() >= eindeSlider->GetValue());
	if (true == fout)
	{
		const auto id = event.GetId();
		wxLogError(_("The start of the pass band must be smaller than the end."));
		
		if (id == BandBeginSliderID)
			beginSlider->SetValue(eindeSlider->GetValue()-1);
		else
			eindeSlider->SetValue(beginSlider->GetValue()+1);
	}
	
	return(fout);
}

/*
 * wxEVT_UPDATE_UI event handler for TestSignaalKeuzeID
 */

void FilterVenster::OnTestSignaalKeuzeIDUpdate( wxUpdateUIEvent& event )
{
	const bool filterIsKlaar = (berekeningKlaar == true) && (testSituatie==false);
	event.Enable(true == filterIsKlaar);
}


/*
 * wxEVT_COMMAND_CHECKBOX_CLICKED event handler for FilterTestID
 */

void FilterVenster::OnFilterTestIDClick( wxCommandEvent& event )
{
	auto *  knop = reinterpret_cast<wxToggleButton *>(FindWindowById(FilterTestID, this));
	
	const bool knopStand = knop->GetValue();
	
	if (knopStand == true)
	{
		filterStart();
	}
	else
	{
		filterStop();
	}
}


/*
 * wxEVT_UPDATE_UI event handler for FilterTestID
 */

void FilterVenster::OnFilterTestIDUpdate( wxUpdateUIEvent& event )
{
	const bool filterIsKlaar = (berekeningKlaar == true);
	event.Enable(true == filterIsKlaar);
}

void FilterVenster::filterStart()
{
	auto * knop = reinterpret_cast<wxToggleButton *>(FindWindowById(FilterTestID, this));
	auto * origBox = reinterpret_cast<wxCheckBox *>(FindWindowById(TekenOrigSignaalID, this));
	auto * splineBox = reinterpret_cast<wxCheckBox *>(FindWindowById(TekenSplineID, this));
	
	testOrig = origBox->GetValue();
	testSpline = splineBox->GetValue();
	
	knop->SetLabel(wxT("Stop FilterTest"));
	
	const RingBuffer<Int16> coeffs(filterCoeffs.Count(), &filterCoeffs[0]);

#ifdef InterfaceTaalNederlands
	const auto precisie = berekenFixedPoint(1.0f);
#elif defined(InterfaceTaalEnglish)
	const auto precisie = computeFixedPoint(1.0f);
#endif
	
	filter = new FilterFirInt16(coeffs,precisie);
	testSituatie = true;
	testIndex = testTekenIndex = 0;
	testGrafiek->maakSchoon();
	filter->reset();
	filterSignaalLijst.Empty();
	klok.Start(100);
	
	/* als "coeffs" uit skoop gaat, dan blijven de pointers toch geldig omdat deze aan filterCoeffs hangen. */
}

void FilterVenster::filterStop()
{
	auto * const knop = dynamic_cast<wxToggleButton *>(FindWindowById(FilterTestID, this));
	
	knop->SetValue(false);
	knop->SetLabel(wxT("Start FilterTest"));
	
	klok.Stop();
	
	testSituatie = false;
	
	/* voor demoversie */
	const auto testGrootte(testGrafiek->GetClientSize());
	testGrafiek->zetGroteTekst(DemoTekst, wxPoint(100, testGrootte.GetHeight() / 2));
	
	delete filter;
}

void FilterVenster::klokVerlopenHandler(wxTimerEvent &event)
{
	const auto testGrootte(testGrafiek->GetClientSize()); // (TestGrafiekBreedte, TestGrafiekHoogte);
	//const Int16 fipSchaal = ; //  testAmplitude; //(MaximumBereikSignedInt(sizeof(Int16))-100)/64;
	const auto schaaly = testGrootte.GetHeight() / (2.0 * testSignaalAmplitudeSlider->GetMax());
	
	Int16 orig;
	
	switch(testSignaalChoice->GetSelection())
	{
		case 0:  /* cosinus */
			orig = static_cast<Int16>(testAmplitude*cos(2*Pi*testIndex*testFreq/sampFreq));
			break;
		case 1: /* blokgolf */
			orig = static_cast<Int16>(testAmplitude*cos(2*Pi*testIndex*testFreq/sampFreq));
			orig = ((orig > 0) ? testAmplitude : -1* testAmplitude);
			break;
		case 2: /* impuls */
			orig = ((testIndex==4) ? testAmplitude : 0);
			break;
		case 3: /* stap */
			orig = ((testIndex<4) ? 0 : testAmplitude);
			break;
		default:
			orig=0;
			wxFAIL_MSG(wxT("Mag hier niet komen !!"));
			break;
	}
	
	const Int16 filterOutput = filter->filter(orig);
	wxLogDebug(wxString::Format(wxT("orig=%d,filter=%d"),orig,filterOutput));
	
	testIndex++;
	
	const wxPoint filterPunt(testTekenIndex+4, static_cast<int>(filterOutput*schaaly));
	
	/* voeg punt toe om aan het eind tekensessie de spline mee te tekenen */
	if (testSpline==true)
		filterSignaalLijst.Add(filterPunt);
	
	if (testTekenIndex == 0)
	{
		static const wxString studentTekst(_("Student version"));
		testGrafiek->maakSchoon();
		testGrafiek->zetGroteTekst(DemoTekst,wxPoint(100, testGrootte.GetHeight() / 2));
	}
	
	if (true == testOrig)  /* teken ook het originele signaal */
	{
		const wxPoint origPunt(testTekenIndex,static_cast<int>(orig*schaaly));
		testGrafiek->zetTekenPen(originalSignalPen);
		testGrafiek->tekenStaaf(origPunt);
	}
	
	testGrafiek->zetTekenPen(filterdSignalPen);
	testGrafiek->tekenStaaf(filterPunt);
	
	testTekenIndex+=8;
	
	if (testTekenIndex>testGrootte.GetWidth())
	{
		if ((testSpline==false) && (testSignaalChoice->GetSelection() < 2))
			testTekenIndex=0;  /* bij cosinus en blokgolf, keer om */
		else
		{
			if (testSpline == true)
				testGrafiek->tekenSpline(filterSignaalLijst);
			
			/* stop de test */
			filterStop();
		}
	}
}

/*
 * wxEVT_COMMAND_SLIDER_UPDATED event handler for TestSignaalFrekID
 */

void FilterVenster::OnTestSignaalFrekIDUpdated( wxCommandEvent& event )
{
	auto * slider = reinterpret_cast<wxSlider *>( FindWindowById(TestSignaalFrekID,this));
	testFreq = slider->GetValue();
}


/*
 * wxEVT_UPDATE_UI event handler for TestSignaalFrekID
 */

void FilterVenster::OnTestSignaalFrekIDUpdate( wxUpdateUIEvent& event )
{
	wxChoice const * const choice = reinterpret_cast<wxChoice *>(FindWindowById(TestSignaalKeuzeID,this));
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* wanneer berekeningKlaar op true wordt gezet */
	event.Enable(((testSituatie == true) || (berekeningKlaar == true)) &&(choice->GetSelection() < 2));
}


/*
 * wxEVT_COMMAND_SLIDER_UPDATED event handler for TestSignaalAmplitudeID
 */

void FilterVenster::OnTestSignaalAmplitudeIDUpdated( wxCommandEvent& event )
{
	auto * slider = reinterpret_cast<wxSlider *>( FindWindowById(TestSignaalAmplitudeID,this));
	testAmplitude = static_cast<Int16>(slider->GetValue());
}


/*
 * wxEVT_UPDATE_UI event handler for TestSignaalAmplitudeID
 */

void FilterVenster::OnTestSignaalAmplitudeIDUpdate( wxUpdateUIEvent& event )
{
	const bool filterIsKlaar = (berekeningKlaar == true);
	event.Enable(true == filterIsKlaar);
}


/*
 * wxEVT_UPDATE_UI event handler for TekenOrigSignaalID
 */

void FilterVenster::OnTekenOrigSignaalIDUpdate( wxUpdateUIEvent& event )
{
	const bool filterIsKlaar = (berekeningKlaar == true);
	event.Enable(true == filterIsKlaar);
}


/*
 * wxEVT_UPDATE_UI event handler for TekenSplineID
 */

void FilterVenster::OnTekenSplineIDUpdate( wxUpdateUIEvent& event )
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* wanneer berekeningKlaar op true wordt gezet */
	event.Enable(( (berekeningKlaar == true)&& (testSituatie != true)));
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for wxID_EXIT
 */

void FilterVenster::OnExitClick( wxCommandEvent& event )
{
	Close();
}


/*
 * wxEVT_UPDATE_UI event handler for wxID_EXIT
 */

void FilterVenster::OnExitUpdate( wxUpdateUIEvent& event )
{
	event.Enable((testSituatie != true) );
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_ABOUT
 */

void FilterVenster::OnAboutClick( wxCommandEvent& event )
{
	auto applikatie = reinterpret_cast<FirFilterKlasse *>(wxTheApp);
	applikatie->geefCopyright(_("Assignment 4 DSB Practicum"),
	                          _("Design and implement a FIR filter design tool based on the sinc() function."));
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ExporteerFilterImpulseBeeldID
 */

void FilterVenster::OnExporteerFilterImpulseBeeldIDClick( wxCommandEvent& event )
{
	tijdDomeinGrafiek->slaOpVeld();
}


/*
 * wxEVT_UPDATE_UI event handler for ExporteerFilterImpulseBeeldID
 */

void FilterVenster::OnExporteerFilterImpulseBeeldIDUpdate( wxUpdateUIEvent& event )
{
	event.Enable( (berekeningKlaar == true));
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for ExporteerFreqBeeldID
 */

void FilterVenster::OnExporteerFreqBeeldIDClick( wxCommandEvent& event )
{
	freqDomeinGrafiek->slaOpVeld();
}


/*
 * wxEVT_UPDATE_UI event handler for ExporteerFreqBeeldID
 */

void FilterVenster::OnExporteerFreqBeeldIDUpdate( wxUpdateUIEvent& event )
{
	/* Dit mag pas als berekening klaar is en geen test wordt gedaan. */
	event.Enable((testSituatie == false) && (berekeningKlaar == true));
}


/*
 * wxEVT_COMMAND_MENU_SELECTED event handler for wxID_SAVE
 */

void FilterVenster::OnSaveClick( wxCommandEvent& event )
{
	wxFileName bestand(dataPad);
	
	wxFileDialog dialoog(this,
	                     _("Save the filter design as a C or CPP header file"),
	                     bestand.GetPath(),
	                     bestand.GetFullName(),
	                     wxT("header file (*.h)|*.h"),
	                     wxFD_SAVE|wxFD_OVERWRITE_PROMPT|wxFD_CHANGE_DIR);
	
	if (wxID_OK == dialoog.ShowModal())
	{
		bestand = wxFileName(dataPad = dialoog.GetPath());
		
		if (wxString(wxT("h")) != bestand.GetExt())
		{
			bestand.SetExt(wxT("h"));
		}
		
		/* schrijf het bestand met deze bestandnaam */
		wxFileOutputStream stroom(bestand.GetFullPath());
		
		if (true != stroom.IsOk())
		{
			wxString fout = _("Could not open:") + bestand.GetFullName();
			wxLogError(fout);
		}
		
		else
		{
			wxTextOutputStream headerBestand( stroom );
			const wxDateTime nu(wxDateTime::Now());
			const auto ditjaar = DitJaar;
			headerBestand.WriteString(wxT("/* Dit is een C/C++ Header bestand                                                                        */\n"));
			headerBestand.WriteString(wxT("/* Opdracht 4 Digitale Signaalbewerking/Digital Signal Processing  ESEDSP                                 */\n"));
			headerBestand.WriteString(wxString::Format(wxT("/* Copyright 2006-%d Opleiding Embedded Systems Engineering, Hogeschool van Arnhem en Nijmegen          */\n"),ditjaar));
			headerBestand.WriteString(wxT("/* Tijdstempel/Time Stamp : ")+nu.FormatISOCombined(' ')+wxT(" */\n"));
			headerBestand.WriteString(wxT("#ifndef FilterCoeffsExport_ESE_H\n"));
			headerBestand.WriteString(wxT("#define FilterCoeffsExport_ESE_H\n"));
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxString::Format(wxT("/* Onderstaande coefficienten zijn voor een bandpass Q%d fixed-point implementatie FIR filter */\n"), fipBitsSpinCtrl->GetValue()-1));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxString::Format(wxT("/* The following coefficients are for a bandpass Q%d fixed-point implementation FIR filter */\n"), fipBitsSpinCtrl->GetValue()-1));
#endif
			headerBestand.WriteString(wxString::Format(wxT("/* Start vd band : %lf*PI (%d Hz @ fs=%d Hz) */\n"),(1.0f*filterBegin)/sampFreq,
			                                           static_cast<UInt32>(filterBegin), static_cast<UInt32>(sampFreq)));
			headerBestand.WriteString(wxString::Format(wxT("/* Eind vd band : %lf*PI (%d Hz @ fs=%d Hz) */\n"),(1.0f*filterEind)/sampFreq,
			                                           static_cast<UInt32>(filterEind), static_cast<UInt32>(sampFreq)));
			headerBestand.WriteString(wxString::Format(wxT("/* Taps : %d */\n\n"),taps));
			
			headerBestand.WriteString(wxT("\n\ntypedef signed short Int16;\n\n"));
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto AantalTaps=%d;\n"), taps));
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto SchaalFaktor=%d;\n\n"), berekenFixedPoint(0.5f)));
			headerBestand.WriteString(wxT("const Int16 filterFixedCoeffs[AantalTaps] = \n{\n"));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto NumberOfTaps=%d;\n"), taps));
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto ScaleFactor=%d;\n\n"), computeFixedPoint(1.0f)));
			headerBestand.WriteString(wxT("const Int16 filterFixedCoeffs[NumberOfTaps] = \n{\n"));
#endif
			/* sla de fixed point coefficienten op. */
			
			for (unsigned int i=0;i<taps;i++)
			{
				const Int16 coeff = filterCoeffs[i];
				
				if (i == taps/2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));
				
				const wxString coeffString(wxString::Format(wxT("%d,"), coeff));
				
				headerBestand.WriteString(coeffString);
				
				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));
				
				if ((0 != i) && (0 == i%5))
					headerBestand.WriteString(wxT("\n"));
			}
			
			headerBestand.WriteString(wxT("\n};\n\n"));
			
			/* sla de floating point coefficienten op. */
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxT("const float filterFloatCoeffs[AantalTaps] = \n{\n"));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxT("const float filterFloatCoeffs[NumberOfTaps] = \n{\n"));
#endif
			for (unsigned int i = 0; i<taps; i++)
			{
#ifdef InterfaceTaalNederlands
				const float coeff = berekenFloatingPoint(filterCoeffs[i]);
#elif defined(InterfaceTaalEnglish)
				const float coeff = computeFloatingPoint(filterCoeffs[i]);
#endif
				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));
				
				wxString coeffString(wxString::Format(wxT("%ff#"), coeff));
				/* vervang alle , door een .*/
				coeffString.Replace(wxT(","), wxT("."));
				coeffString.Replace(wxT("#"), wxT(","));
				headerBestand.WriteString(coeffString);
				
				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));
				
				if ((0 != i) && (0 == i % 5))
					headerBestand.WriteString(wxT("\n"));
			}
			
			headerBestand.WriteString(wxT("\n};\n\n"));
			headerBestand.WriteString(wxT("#endif /* FilterCoeffsExport_ESE_H */\n\n"));
			
			wxLogMessage(_("Header file written succesfully."));
		}
	}
}


/*
 * wxEVT_UPDATE_UI event handler for wxID_SAVE
 */

void FilterVenster::OnSaveUpdate( wxUpdateUIEvent& event )
{
	/* Dit mag pas als berekening klaar is en geen test wordt gedaan. */
	event.Enable((testSituatie == false) && (berekeningKlaar == true));
}


/*
 * wxEVT_UPDATE_UI event handler for ToonAnalogeFrekID
 */

void FilterVenster::OnToonAnalogeFrekIDUpdate( wxUpdateUIEvent& event )
{
	/* Dit mag pas als berekening klaar is en geen test wordt gedaan. */
	event.Enable((testSituatie == false) && (berekeningKlaar == true));
}


/*
 * wxEVT_ENTER_WINDOW event handler for tijdDomeinGrafiek
 */

void FilterVenster::OnEnterWindow( wxMouseEvent& event )
{
	const auto winid = event.GetId();
	
	if (FreqDomeinGrafiekID == winid)
		freqViewBinnenkomstHandler(event);
	else if (TijdDomeinGrafiekID == winid)
		tijdViewBinnenkomstHandler(event);
}


/*
 * wxEVT_LEAVE_WINDOW event handler for tijdDomeinGrafiek
 */

void FilterVenster::OnLeaveWindow( wxMouseEvent& event )
{
	const auto winid = event.GetId();
	
	if (FreqDomeinGrafiekID == winid)
		freqViewBuitengangHandler(event);
	else if (TijdDomeinGrafiekID == winid)
		tijdViewBuitengangHandler(event);
}

/*
 * wxEVT_MOTION event handler for TijdDomeinGrafiekID
 */
void FilterVenster::OnMotion( wxMouseEvent& event )
{
	const auto winid = event.GetId();
	
	if (FreqDomeinGrafiekID == winid)
		freqViewMuisBewegingHandler(event);
	else if (TijdDomeinGrafiekID == winid)
		tijdViewMuisBewegingHandler(event);
}
/*
 * wxEVT_COMMAND_CHECKBOX_CLICKED event handler for ToonFilterKoeffsID
 */

void FilterVenster::OnToonFilterKoeffsIDClick( wxCommandEvent& event )
{
	auto const * const cb = static_cast<wxCheckBox*>(FindWindowById(ToonFilterKoeffsID, this));
	
	toonCoeffs = cb->GetValue();
	
	if ((0 != filterCoeffs.GetCount()) && (true == cb->IsChecked()))
	{
		for(signed int n=-1*orde;n<orde+1;n++)
		{
			const Int16 coeff = filterCoeffs[n+orde];
#ifdef InterfaceTaalNederlands
			wxLogMessage(wxString::Format(_("Coefficient[%d] = %d (float:%f)"),n,coeff,berekenFloatingPoint(coeff)));
#else
			wxLogMessage(wxString::Format(_("Coefficient[%d] = %d (float:%f)"), n, coeff, computeFloatingPoint(coeff)));
#endif
		}
	}
}

/*
 * wxEVT_UPDATE_UI event handler for ToonFilterKoeffsID
 */

void FilterVenster::OnToonFilterKoeffsIDUpdate( wxUpdateUIEvent& event )
{
	/* Dit mag pas als berekening klaar is en geen test wordt gedaan. */
	event.Enable((testSituatie == false) && (berekeningKlaar == true));
}

/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for HANLogoID
 */

void FilterVenster::OnHANLogoIDClick( wxCommandEvent& event )
{
	static const wxString eseURL(wxT("https://www.han.nl/opleidingen/hbo/embedded-systems-engineering/voltijd/index.xml"));
	wxLaunchDefaultBrowser(eseURL);
}

